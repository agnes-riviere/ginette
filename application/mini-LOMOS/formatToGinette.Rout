
R version 4.0.2 (2020-06-22) -- "Taking Off Again"
Copyright (C) 2020 The R Foundation for Statistical Computing
Platform: x86_64-pc-linux-gnu (64-bit)

R est un logiciel libre livré sans AUCUNE GARANTIE.
Vous pouvez le redistribuer sous certaines conditions.
Tapez 'license()' ou 'licence()' pour plus de détails.

R est un projet collaboratif avec de nombreux contributeurs.
Tapez 'contributors()' pour plus d'information et
'citation()' pour la façon de le citer dans les publications.

Tapez 'demo()' pour des démonstrations, 'help()' pour l'aide
en ligne ou 'help.start()' pour obtenir l'aide au format HTML.
Tapez 'q()' pour quitter R.

Microsoft R Open 4.0.2
The enhanced R distribution from Microsoft
Microsoft packages Copyright (C) 2020 Microsoft Corporation

Using the Intel MKL for parallel mathematical computing (using 1 cores).

Default CRAN mirror snapshot taken on 2020-07-16.
See: https://mran.microsoft.com/.

[Sauvegarde de la session précédente restaurée]

> #LIBRARY
> #---- Interpolate timeseries to match the time discretization ----
> library(stats) #for spline interpolation
> library(lubridate)

Attachement du package : ‘lubridate’

The following objects are masked from ‘package:base’:

    date, intersect, setdiff, union

> library(stringr)
> library(ggplot2)
> library(stringr)
> library(RColorBrewer)
> library(data.table)

Attachement du package : ‘data.table’

The following objects are masked from ‘package:lubridate’:

    hour, isoweek, mday, minute, month, quarter, second, wday, week,
    yday, year

> library(readr)
> setwd(dir = ".")
> getwd()
[1] "/home/ariviere/Programmes/ginette/application/mini-LOMOS"
> 
> # read comm
> #File_com = list.files(pattern = "test_")
> File_com = "inversion.COMM"
> Inversion_PT100 = "inversion_PT100.COMM"
> depth_PT100 = read.csv(Inversion_PT100, sep = " ", header = FALSE) #écart entre les PT100 en cm
> 
> com = read.csv(File_com, sep = " ", header = FALSE)
> point_name=com$V1
> temp_sensor=com$V5
> pres_sensor=com$V6
> #initial date
> dg_year =com$V2
> ini_year = as.numeric(paste0('20',dg_year))
> ini_month = com$V3
> dg_month = sapply(ini_month, function(x) paste(paste(rep(0, 2 - nchar(x)), collapse = ""), x, sep = ""))
> ini_day = com$V4
> dg_day=sapply(ini_day, function(x) paste(paste(rep(0, 2 - nchar(x)), collapse = ""), x, sep = ""))
> ini_date = paste0(ini_day, '/', ini_month, '/', ini_year)
> ini_date = as.POSIXct(ini_date, '%d/%m/%Y', tz = 'GMT')
> cal_time=com$V11
> 
> # #---- discretisation parameters for Ginette ----
> Deltaz = 0.01 # [m]
> Deltat = com$V7 # [s]
> 
> # number obs PT100 in the hyporheic zone to inv
> nPT100 = com$V8
> 
> # name HZ temperature
> temp_file=paste0(temp_sensor,"_",point_name,"_",dg_day,"_",dg_month,"_",dg_year,".csv")
> temp_data=fread(temp_file)
> 
> # number obs PT100 in the hyporheic zone, the last (deeper) one is used as boundary condition
> ntemp= ncol(temp_data)-2
> if (ntemp>4) { ntemp=4
+   
+ }
> tempHobbo=data.frame(temp_data)
> tempHobbo$dates = as.POSIXct(temp_data$dates,'%d/%m/%Y %H:%M:%S', tz = 'GMT')
> 
> # read data pressure and river temperature
> river_file=paste0(pres_sensor,"_",point_name,"_",dg_day,"_",dg_month,"_",dg_year,".csv")
> riverHobbo=fread(river_file)
> riverHobbo$dates = as.POSIXct(temp_data$dates,'%d/%m/%Y %H:%M:%S', tz = 'GMT')
> nriver= ncol(riverHobbo)-2
> 
> if (nriver>2) { nriver=2
+ 
+ }
> presDiff=data.frame(riverHobbo$dates,riverHobbo$pressure_differential_m)
> stream_temp=data.frame(riverHobbo$dates,riverHobbo$temperature_stream_C)
> 
> #---- add consider timeseries from date of initial conditions ----
> ini_pres= as.POSIXct(presDiff[1,1],'%d/%m/%Y %H:%M',tz='GMT')
> end_pres=as.POSIXct(presDiff[dim(presDiff)[1],1],'%d/%m/%Y %H:%M',tz='GMT')
> 
> timeInitial = as.POSIXct(tempHobbo$dates[1],'%d/%m/%Y %H:%M',tz='GMT')
> timeFinal = as.POSIXct(tempHobbo$dates[dim(tempHobbo)[1]],'%d/%m/%Y %H:%M',tz='GMT')
> 
> ### DEPEND DE cal_time !!!!
> end_date = max(timeInitial,ini_pres) + cal_time
> 
> # reference times and dates starting from max(timeInitial,ini_obs)
> t_time = seq(from = max(timeInitial,ini_pres),
+              to = min(end_pres,timeFinal, end_date),
+              by = as.difftime(Deltat, units = "secs"))
> 
> t_dates = seq(from = strptime(paste0(as.character(t_time[1],format="%Y-%m-%d")," 00:00"),format = "%Y-%m-%d %H:%M"),
+               to = strptime(paste0(as.character(t_time[length(t_time)],format="%Y-%m-%d")," 00:00"),format = "%Y-%m-%d %H:%M"),
+               by = as.difftime(1, units = "days"))
> 
> # points where interpolation is to take place
> xOut = as.numeric(difftime(t_time,t_time[1],units = "secs"))
> 
> xInit1 = as.numeric(difftime(presDiff[,1], t_time[1],units = "secs"))
> presDiffInterp = spline(x=xInit1, y=presDiff[,2], xout = xOut)$y
> #plot(xOut,presDiffInterp,type='l',xlim=c(50000,855000),ylim=c(-0.4,0.05))
> 
> xInit2 = as.numeric(difftime(stream_temp[,1], t_time[1], units = "secs"))
> tempStreamInterp = spline(x=xInit2,y=stream_temp[,2],xout = xOut)$y
> #plot(xOut,tempStreamInterp,type='l',xlim=c(50000,55000))
> 
> xInit3 = as.numeric(difftime(tempHobbo$dates, t_time[1], units = "secs"))
> tempHobboInterp = array(0, dim = c(length(xOut), ntemp))
> 
> for (i in 1:ntemp){
+   tempHobboInterp[,i] = spline(x = xInit3, y = tempHobbo[, i+2], xout = xOut)$y
+ }
> 
> #plot(xOut,tempHobboInterp[,1],type='l',xlim=c(50000,70000))
> # points(xInit,tempHobbo[,1])
> 
> #----define data for Ginette model----
> sensorDepths = vector(length = ntemp)
> for (i in 1:ntemp){
+   if(i==1) {
+     sensorDepths[i]=0-as.integer(depth_PT100[i,])*Deltaz
+   } else {
+     sensorDepths[i]=0+sensorDepths[i-1]-as.integer(depth_PT100[i,])*Deltaz
+   }
+ }
> 
> z = seq(from = -Deltaz/2,
+         to = sensorDepths[length(sensorDepths)] + Deltaz/2,
+         by=-Deltaz)
Error in seq.default(from = -Deltaz/2, to = sensorDepths[length(sensorDepths)] +  : 
  'to' must be a finite number
Calls: seq -> seq.default
Exécution arrêtée
